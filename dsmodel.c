#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model FM3217_2020_VM.Tutorial3.Tests.DCGeneratorTest
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Sun Sep 13 20:28:07 2020

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    2
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    39
#define NP_    10
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -2082165913
#define NHash2_ -230330364
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    33
#define SizePre_ 0
#define SizeEq_ 1
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="FM3217_2020_VM.Tutorial3.Tests.DCGeneratorTest";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/veronika/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[6]={1 , 2 , 1 , 2 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[3]={
2 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[3]={0  , 44 , 55};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,5) = false;
DYNX(W_,15) = false;
DYNX(W_,30) = 3;
DYNX(W_,36) = 3;
DYNX(W_,37) = false;
DYNX(W_,11) = 0.0;
DYNX(W_,10) = 0.0;
DYNX(W_,18) = 0.0;
DYNX(W_,38) = 0;
DYNX(W_,1) = 0.0;
DYNX(W_,9) = 0.0;
DYNX(W_,34) = 0;
DYNX(W_,7) = 0.0;
DYNX(W_,28) = 0.0;
DYNX(W_,24) = 0.0;
DYNX(W_,23) = 0.0;
DYNX(W_,16) = 0.0;
DYNX(W_,26) = 0.0;
DYNX(W_,25) = 0.0;
DYNX(W_,22) = 0.0;
DYNX(W_,21) = 0.0;
DYNX(W_,20) = 0.0;
DYNX(W_,19) = 0.0;
DYNX(W_,27) = 0.0;
DYNX(W_,13) = 0.0;
DYNX(W_,12) = 0.0;
DYNX(W_,29) = 0.0;
DYNX(W_,35) = 0.0;
DYNX(W_,33) = 0.0;
DYNX(W_,2) = 0.0;
DYNX(W_,4) = 0.0;
DYNX(W_,3) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,0) = DYNX(DP_,0);
DYNX(W_,6) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)) >= 1E-15,"1+dCMachine.resistor.alpha*(dCMachine.resistor.T-dCMachine.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,14) = DYNX(DP_,6);
BoundParameterConstantSection
DYNX(W_,8) = DYNX(W_,0)*(1+DYNX(DP_,2)*(DYNX(W_,6)-DYNX(DP_,1)));
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 0);
SolveScalarLinearParametric(DYNX(DP_,8)+DYNX(DP_,5),"inertia.J+dCMachine.inertia.J",
   DYNX(DP_,9),"constantTorque.tau_constant", DYNX(F_,1),"der(inertia.w)");
DYNX(W_,31) = DYNX(DP_,5)*DYNX(F_,1);
 /* End of Equation Block */ 

DYNX(F_,0) = DYNX(X_,1);

AcceptedSection1

AcceptedSection2
DYNX(W_,17) = DYNX(X_,0)-DYNX(DP_,4);
DYNX(W_,32) = DYNX(DP_,3)*DYNX(X_,1);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("dCMachine.R", "Resistance of the armature [Ohm]", 0, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("dCMachine.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("dCMachine.resistor.T_ref", "Reference temperature [K|degC]", 1,\
 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("dCMachine.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("dCMachine.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.resistor.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("dCMachine.resistor.p.v", "Potential at the pin [V]", \
"dCMachine.p.v", 1, 5, 32, 4)
DeclareVariable("dCMachine.resistor.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("dCMachine.resistor.n.v", "Potential at the pin [V]", \
"dCMachine.p.v", 1, 5, 32, 4)
DeclareVariable("dCMachine.resistor.n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("dCMachine.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dCMachine.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dCMachine.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("dCMachine.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "dCMachine.resistor.T", 1, 5, 6, 0)
DeclareVariable("dCMachine.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.inductor.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("dCMachine.inductor.p.v", "Potential at the pin [V]", \
"dCMachine.p.v", 1, 5, 32, 4)
DeclareVariable("dCMachine.inductor.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("dCMachine.inductor.n.v", "Potential at the pin [V]", \
"dCMachine.p.v", 1, 5, 32, 4)
DeclareVariable("dCMachine.inductor.n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("dCMachine.inductor.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dCMachine.emf.k", "Transformation coefficient [N.m/A]", 3, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("dCMachine.emf.v", "Voltage drop between the two pins [V]", \
"dCMachine.p.v", 1, 5, 32, 0)
DeclareVariable("dCMachine.emf.i", "Current flowing from positive to negative pin [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia.w", 1, 1, 1, 0)
DeclareAlias2("dCMachine.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "inertia.w", 1, 1, 1, 0)
DeclareVariable("dCMachine.emf.tau", "Torque of flange [N.m]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("dCMachine.emf.tauElectrical", "Electrical torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("dCMachine.emf.p.v", "Potential at the pin [V]", "dCMachine.p.v", 1,\
 5, 32, 4)
DeclareVariable("dCMachine.emf.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("dCMachine.emf.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("dCMachine.emf.n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("dCMachine.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareVariable("dCMachine.emf.flange.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("dCMachine.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 4, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("dCMachine.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 4, 1028)
DeclareVariable("dCMachine.emf.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("dCMachine.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("dCMachine.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 4, 1024)
DeclareAlias2("dCMachine.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 4, 1028)
DeclareVariable("dCMachine.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("dCMachine.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("dCMachine.ground.p.i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("dCMachine.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareVariable("dCMachine.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("dCMachine.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareAlias2("dCMachine.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.flange_b1.tau", 1, 5, 31, 132)
DeclareParameter("dCMachine.inertia.J", "Moment of inertia [kg.m2]", 5, 1, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("dCMachine.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("dCMachine.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "inertia.phi", 1, 1, 0, 0)
DeclareAlias2("dCMachine.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia.w", 1, 1, 1, 0)
DeclareAlias2("dCMachine.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "inertia.w", 1, 1, 1, 0)
DeclareAlias2("dCMachine.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "inertia.der(w)", 1, 6, 1, 0)
DeclareAlias2("dCMachine.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 1, 0)
DeclareAlias2("dCMachine.flange_b1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareVariable("dCMachine.flange_b1.tau", "Cut torque in the flange [N.m]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("dCMachine.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("dCMachine.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareVariable("dCMachine.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("dCMachine.n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareParameter("dCMachine.L", "Inductance of DC Machine [H]", 6, 0.1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("dCMachine.J", "Moment of inertia [kg.m2]", 7, 0.1, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareAlias2("inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"dCMachine.flange_b1.tau", -1, 5, 31, 132)
DeclareAlias2("inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareAlias2("inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"constantTorque.tau_constant", 1, 7, 9, 132)
DeclareParameter("inertia.J", "Moment of inertia [kg.m2]", 8, 1, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("inertia.phi", "Absolute rotation angle of component [rad|deg]", 0,\
 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 1, 0)
DeclareVariable("constantTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("constantTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 0, 4)
DeclareAlias2("constantTorque.flange.tau", "Cut torque in the flange [N.m]", \
"constantTorque.tau_constant", -1, 7, 9, 132)
DeclareVariable("constantTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("constantTorque.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "inertia.phi", 1, 1, 0, 0)
DeclareAlias2("constantTorque.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia.w", 1, 1, 1, 0)
DeclareParameter("constantTorque.tau_constant", "Constant torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 9, 10, 0.0,0.0,0.0,0,560)
DeclareAlias2("constantTorque.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "inertia.w", 1, 1, 1, 0)
DeclareAlias2("constantTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "constantTorque.tau_constant", 1, 7, 9, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,1), 0.0, 0);
EndEqBlock
EndDataBlock
